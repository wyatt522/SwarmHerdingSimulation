#include "/Buzz/src/include/vec2.bzz"

include "/home/ashley/Downloads/buzz/src/include/vec2.bzz"

numMechFaultAgents = 2;
totalAgents = 20;


# This function is executed once at init time
function init() {
	# SWARM CREATION
	shepherd_swarm = swarm.create(1)
	sheep_swarm = swarm.create(2)
	
	shepherd_swarm.select(id == 0)
	sheep_swarm.select(id > 0)

	# SHEEP CONSTANTS
	num_sheep = 20 # THIS IS UPDATED IN HERDING.ARGOS
	base_velocity = 20

	repulsion_weight = 2
	cohesion_weight = 1.05
	escape_weight = 1
	
	repulsion_radius = 40
	shepherd_radius = 1300
	sheep_kp = 6

	# SHEPHERD CONSTANTS
	shepherd_vel = 30
	FN = (repulsion_radius)*(math.sqrt(num_sheep))
	target_location = math.vec2.new(-3000, -3000)
	shepherd_kp = 9
}

# This function is executed at each time step
# The main loop is controller by ARGoS

function step()
{
	sheep_swarm.exec(sheep_step)
	shepherd_swarm.exec(shepherd_step)
	#mechFault_swarm.exec(mechFault_step)

	
}

function mechFault_step()
{

	drive_direction(0.0, 0.0, 0.0)
	set_leds(255, 255, 0)
}

function table_print(t) {
  foreach(t, function(key, value) {
      log(key, " -> ", value)
    })
}

function shepherd_step()
{
	

  vThreshold = 1;

	sheep = neighbors.nonkin()

	#remove the sheep that arent moving from the swarm
	movingSheep = swarm.create(4)

	t = { .1=0, .2=0, .3=0, .4=0, .5=0, .6=0, .7=0, .8=0, .9=0, .10=0, .11=0, .12=0, .13=0, .14=0, .15=0, .16=0, .17=0, .18=0, .19=0 }


	log("shepherd ", id)
	log(" count1 ", sheep.count())

sheep = sheep.filter(function(rid, data) {
# We assume the distance is expressed in centimeters
return rid > 3 })


	log(" count2 ", sheep.count())


	#end of remove the sheep that arent moving from the swarm
	
	center = math.vec2.new(0, 0)
	
	total_sheep = 0
	foreach(sheep.poses, function(key, value) {
		diff = dist_ang_to_vec(value)
		center = math.vec2.add(center, diff)
		total_sheep = total_sheep + 1
	})
	center = math.vec2.scale(center, (1.0/total_sheep))
	
	# Identify Closest agent outside of herd radius
	furthest_agent = -1
	
	furthest_agent_pos = center
	furthest_agent_vec_center = math.vec2.new(0.0, 0.0)
	furthest_agent_distance = 0
	furthest_agent_proximity = 30000

	touching_agent = 0
	herd_compressed = 1
	foreach(sheep.poses, function(key, value) {
		diff = dist_ang_to_vec(value)
		vec_from_center = math.vec2.sub(diff, center)
		dist_from_center = math.vec2.length(vec_from_center)
		proximity = math.vec2.length(diff)
		
		if (dist_from_center > FN)
		{
			herd_compressed = 0
			if (proximity < furthest_agent_proximity)
			{
				furthest_agent = key
				furthest_agent_pos = diff
				furthest_agent_vec_center = vec_from_center
				furthest_agent_distance = dist_from_center
				furthest_agent_proximity = proximity
			}
		}
		
		# STOP IF PUSHING SHEEP
		if (proximity < (3*repulsion_radius))
		{
			touching_agent = 1
		}
		
	})
	
	if ((total_sheep > 1))
	{
		target_direction = 0.0
		if (herd_compressed == 0)
		{
			# COLLECTING -> TARGET DIRECTION SET TO BEHIND FURTHEST AGENT
			# RED
			set_leds(255, 0, 0)
			# go directly behind the furthest agent
			norm_center_diff_vec = math.vec2.norm(furthest_agent_vec_center)
			offset = math.vec2.scale(norm_center_diff_vec, repulsion_radius)
			goal = math.vec2.add(furthest_agent_pos, offset)
		
			target_direction = math.vec2.angle(goal)
		}
		else if (herd_compressed == 1)
		{
			# DRIVING -> TARGET DIRECTION SET TO BEHIND CENTER OF PACK
			# WHITE
			set_leds(255, 255, 255)
			
			my_pose = math.vec2.new(pose.position.x, pose.position.y)
			my_pose = math.vec2.scale(my_pose, 1000)
			rotation = pose.orientation.yaw
			shep_to_center = math.vec2.rotate(center, rotation)
			center_world_frame = math.vec2.add(my_pose, shep_to_center)
			center_to_goal = math.vec2.sub(target_location, center_world_frame)
			offset_direction = math.vec2.norm(center_to_goal)
			offset = math.vec2.scale(offset_direction, -(repulsion_radius*math.sqrt(num_sheep)))
			goal_world_frame = math.vec2.add(center_world_frame, offset)
			goal_shepherd_frame = math.vec2.sub(goal_world_frame, my_pose)
			goal_shepherd_frame = math.vec2.rotate(goal_shepherd_frame, -rotation)
			
			target_direction = math.vec2.angle(goal_shepherd_frame)
			# Print Center Location
			# log("center in world frame: ", center_world_frame.x, ", ", center_world_frame.y)
			}
	
		# go to goal
		if (touching_agent == 0)
		{
			drive_direction(target_direction, shepherd_vel, shepherd_kp)
		}
		else
		{
			# CLOSE TO AGENT -> SLOW DOWN
			drive_direction(target_direction, (shepherd_vel*0.3), (shepherd_kp*0.5))
		}
	}
	else
	{
		# CAN'T FIND HERD -> STAND STILL
		# GREEN
		set_leds(0, 255, 0)
		set_wheels(0.0, 0.0)
	}
}

function sheep_step() {
	set_leds(0, 0, 255)
	sheep = neighbors.kin()
	shepherds = neighbors.nonkin()

	cohesion = math.vec2.new(0, 0)
	repulsion = math.vec2.new(0, 0)
	escape = math.vec2.new(0, 0)
	
	foreach(sheep.poses, function(key, value) {
		diff = dist_ang_to_vec(value)
		cohesion = math.vec2.add(cohesion, diff)
		if(math.vec2.length(diff) < repulsion_radius)
		{
			norm_diff = math.vec2.norm(diff)
			repulsion = math.vec2.sub(repulsion, norm_diff)
		}    })

	foreach(shepherds.poses, function(key, value) {
		diff = dist_ang_to_vec(value)
		if(math.vec2.length(diff) < shepherd_radius)
		{
			norm_diff = math.vec2.norm(diff)
			escape = math.vec2.sub(escape, diff)
		} })

	cohesion = safe_scale(cohesion, cohesion_weight)
	repulsion = safe_scale(repulsion, repulsion_weight)
	escape = safe_scale(escape, escape_weight)
	
	direction_vector = math.vec2.add(cohesion, math.vec2.add(repulsion, escape))
	target_direction = math.vec2.angle(direction_vector)
	

	#make the faulty robots not move
	if ((id > 0) and (id <= numMechFaultAgents))
	{
	target_direction = 0.0
	base_velocity = 0.0
	sheep_kp = 0.0
	set_leds(255, 255, 0)
	}

	drive_direction(target_direction, base_velocity, sheep_kp)
}

function dist_ang_to_vec(value) {
		x = value.distance * math.cos(value.elevation) *
          math.cos(value.azimuth)
    y = value.distance * math.cos(value.elevation) *
          math.sin(value.azimuth)
		diff = math.vec2.new(x, y)
		return diff
	}

function safe_scale(vector, scale) {
	if (math.vec2.length(vector) != 0)
	{
		vector = math.vec2.norm(vector)
		vector = math.vec2.scale(vector, scale)
		return vector
	}
	else
	{
		return vector
	}
}

function drive_direction(target_direction, base_v, turn_kp) {
	set_wheels(base_v - target_direction*turn_kp, base_v + target_direction*turn_kp)

	neighbors.broadcast("vel", base_v);
	
}

# This function is executed when you press the reset button
function reset() {
	
}

# This function is executed once when you close the simulator
function destroy() {
}
